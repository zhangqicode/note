### let 命令
* let 只在所在的代码块内有效
* 变量提升和暂时性死区两节可以总结为：用 let 的时候要先声明后使用（用 var 的时候最好也这样）
* let 不允许重复声明：在相同作用域内同一个变量名不能重复声明

### 块级作用域
* 不明白为什么会有人设计“变量提升”这么蛋疼的特性，先声明再使用不是很好吗？
* 为什么需要块级作用域？因为“变量提升”会把作用域搞乱
* let实际上为 JavaScript 新增了块级作用域，比较符合我的认知，var 的作用域太玄幻了，所以尽量用 let 吧
* 尽量不要在块级作用域内定义函数，如果一定要定义，就使用函数表达式
* 使用块级作用域注意加大括号，ESLint 应该会帮我们避免这种问题

### const 命令
* const 声明一个只读的常量
* const 也只在块作用域内生效，没有“提升”
* 先声明，后使用，很好很规范
* const 常量指向对象时，对象中的内容仍然可以被改变
* 如果真的想将对象冻结，应该使用Object.freeze方法

### 顶层对象的属性
* ES6 一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性
* 还是尽量用 let 修饰符

### globalThis 对象
* 一个获取顶层对象的提案，目的是为了方便的在各种环境下通过同一属性取得顶层对象

### 总结
* 感觉 ES6 在语言规范方面做出了努力，减少不确定的复杂的用法（例如 var 的变量提升），让语言变得规范统一