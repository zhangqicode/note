## 概要

单源最短路径问题产生的基础是，带权重的有向图  

最短路径的含义是，两个结点之间的路径中，总权重和最小的路径  

单源最短路径问题是指，在一个带权重的有向图中，找到从给定源结点到其它每个结点的最短路径  

#### 最短路径的几个变体

* 单目的地最短路径问题  
* 单结点对最短路径问题  
* 所有结点对最短路径问题  

#### 最短路径的最优子结构  

引理 24.1 最短路径的子路径也是最短路径  

#### 负权重的边  

如果图中不包含可以到达的权重为负值的环路，则所有结点的最短路径权重都有精确定义  
如果包含权重为负值的环路，则环路中的结点最短路径权重都为负无穷

#### 环路

一条最短路径不能包含权重为正值或负值的环路，如果路径中包含权重为 0 的环路，我们可以重复删除这些环路，直到得到一条不含环路的最短路径  
所以在之后的讨论中我们假设最短路径都不包含环路

#### 最短路径的表示

运行最短路径算法得到一个由 π 诱导的前驱子图，这个前驱子图是一颗最短路径树  
树中的简单路径都是相应结点之间的一条最短路径  
最短路径不一定是唯一的，最短路径树也不一定是唯一的  

#### 松弛操作

* 对一条边（u,v）松弛的过程是指，比较 v.d（v 的当前最短路径估计）与 u.d + w(u,v) 的值，根据比较结果决定是否更新 v.d  
* 本章所有算法都要用松弛操作更新最短路径估计的值，各算法的区别只是松弛操作的次数和次序不同  

#### 最短路径和松弛操作的性质

* 三角不等式性质
* 上界性质
* 非路径性质
* 收敛性质
* 路径松弛性质
* 前驱子图性质

## Bellman-Ford 算法

Bellman-Ford 算法思路是对所有的边都进行一次松弛操作，循环 V 遍，用于解决一般情况下的单源最短路径问题（允许权重为负值）  
Bellman-Ford 算法会返回一个布尔值，当图中包含权重为负值的环路时，返回 FALSE，否则返回 TRUE  
算法的性能为 O(VE)  

引理 24.2 证明了在不考虑权重为负值的环路时，Bellman-Ford 算法中的循环可以将所有结点的最短路径估计 d 收敛为最短路径值  
推论 24.3 说明了在不考虑权重为负值的环路时，Bellman-Ford 算法终止时，对所有结点 v，存在从 s 到 v 的路径当且仅当 v.d < ∞  
定理 24.4 最终证明了算法的正确性  




