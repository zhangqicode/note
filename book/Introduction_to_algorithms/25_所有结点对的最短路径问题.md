## 概要

* 可以通过对每个结点运行一次上一章中的最短路径算法，来解决所有结点对的最短路径问题，但效率较低，本章考虑的是用新的算法更高效的解决此问题
* 本章使用邻接矩阵来表示图，边的权重也存储在一个矩阵 W 中，算法的输出存储在矩阵 D 中，还有一个精妙的前驱结点矩阵用于存放路径结果
* 前驱结点矩阵的位置 ij 中存储的是，由 i 到 j 的一条最短路径中，j 的前驱结点
* 由前驱结点矩阵的第 i 行可以诱导出，由结点 i 出发的最短路径树

## 最短路径和矩阵乘法

`实话说在这一节我觉得智力不够用了`
  
这一节是使用动态规划的方法解决所有结点对的最短路径问题，按动态规划的设计方法，有四个步骤

#### 步骤一：分析最优解结构
* 最优解必定是由子问题的最优解构成的，让本章的问题符合这一性质的是引理 24.1，一条最短路径的所有子路径都是最短路径

#### 步骤二：所有结点对最短路径的递归解
* 这一段的分析过程基本没看明白，主要的目的是给出一个递归式，指明由子问题的解如何组成问题的解
* 公式给了两个，第一个公式 25.2 指出了如何由子问题的解组成问题的解，第二个公式 25.3 结合路径权重的场景具体分析，指出大于 n-1 条边的权重矩阵中的权重值都等于 n-1 条边的权重矩阵

#### 步骤三：自底向上计算最短路径权重
* 计算的算法并不出奇，三层 for 循环遍历，利用公式 25.2 进行递归计算（递归应该算作第四次循环）
* 神奇的是这里计算的时候将公式 25.2 转成了矩阵乘法（没明白是如何转换的，数学功力不够），转成矩阵乘法之后算法的表述就变得更简单了，里面的三层 for 循环就是矩阵相乘的过程，外面的递归变成了不断的与同一个矩阵做乘法

#### 步骤三改进：重复平方
* 结合路径权重的场景分析，我们只需要最终的权重矩阵，对计算的中间结果不感兴趣，利用 25.3 给出的性质，递归计算改为平方计算，即中间结果的矩阵与自己相乘，这样找出一个大于 n-1 阶的结果即可
* 这个改进可以将递归中的 O(n) 优化到 O(lgn)

#### 步骤四：构建最优解
* 书中没有给出这一步骤，我思考就是利用概要中给出的方法，由前驱结点矩阵诱导出最短路径树
