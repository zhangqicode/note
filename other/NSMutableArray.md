### 数组是如何存储的
* C 语言中的数组是顺序存储的，一段连续的内存，每个容量单位存储一个元素
* OC 中的数组是如何存储的，这里有一篇文章详细探索了这个过程：[探索iOS数组容器的存储结构](https://www.jianshu.com/p/325abcded1df)，其结论是 NSArray 和 NSMutableArray 都是顺序存储的
* 那么就产生了一个问题，NSMutableArray 在使用过程中是如何保证存储空间是足够的？我们可以向可变数组中添加任意数量的元素，那么系统应该为可变数据分配多大的一段连续内存呢？

### Capacity
* 我们可能注意到 NSMutableArray 有这样一个方法 initWithCapacity，可以传入一个 int 值，表明我们预计会使用到的数组规模
* Capacity 对于解决上述问题有一定的帮助，但不能完全解决问题。传入 Capacity 值只是一个辅助作用，系统也不会完全依赖这个值来决定内存分配。
* 事实上，Capacity 的作用基本上等于没有，可以参看这篇文章：[Exposing NSMutableArray](https://ciechanow.ski/exposing-nsmutablearray/)。Capacity 会使系统给可变数组分配一个接近的容量，这个容量可能是 2，4，8，16，但不会变的更大了。

### 扩容
* 可变数组会有一个我们无感知的系统操作：扩容，即当分配的容量不够时，重新给数组分配一块更大的内容，并将数组的内容复制到新内存区域。
* 在这篇文章中：[探索iOS数组容器的存储结构](https://www.jianshu.com/p/325abcded1df)，我们可以读到一个事实，当不断的向可变数组中添加元素时，数组的内存地址偶尔会发生变化，这就证明了数组扩容操作的存在。
* 扩容的规则：当数组分配的内容被占满时，触发扩容操作，系统重新分配一块以固定比例（1.625）扩大的内存，并复制内容。

### NSMutableArray 的实现
* 将一段连续的内存作为循环队列使用，用 size，used，offset 来标记队列的使用情况。size 表示队列占用的内存大小，offset 表示第一个元素所在的位置，used 表示元素的数量。

### 简单性能分析
* 可变数组上的基本操作有：增加，删除，替换。
* 增加又可以分为“触发扩容”的增加操作和“不触发扩容”的增加操作。

### 增加 & 删除
* “触发扩容”的增加操作，需要复制已有的所有元素，时间复杂度为 O(n)
* “不触发扩容”的增加操作，在数组的收尾增加元素时，时间复杂度为 O(1)，中间增加元素时，为 O(n)，删除操作相同

### 替换
* 替换操作，时间复杂度为 O(1)

### 摊还分析
* 摊还分析是对数据结构的一组操作进行分析，以一组操作的性能耗费来评价数据结构的性能。
* 简单示例，我们来分析一组 addObject 操作的平均性能。
* 用势能法做摊还分析，可得结论：在可变数组上执行任意 n 个 addObject 操作的实际运行时间是 O(n)

### 扩容后如何访问新的内存空间
* 猜想是可变数组内部还有一层包装，NSMutableArray 的某个属性 x 才是真正的数组地址，在数组扩容后只要将 x 指向新的地址即可，用户没有感知








